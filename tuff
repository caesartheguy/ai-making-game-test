<!DOCTYPE html>
// --- SETUP ---
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');

canvas.width = 1024;
canvas.height = 576;

// --- CONSTANTS ---
const GRAVITY = 0.7;

// --- UI ELEMENTS ---
const player1HealthBar = document.getElementById('player1-health');
const player2HealthBar = document.getElementById('player2-health');
const gameOverDisplay = document.getElementById('game-over-display');
const winnerText = document.getElementById('winner-text');
const restartButton = document.getElementById('restart-button');
const timerDisplay = document.getElementById('timer');

// --- CLASSES ---
class Sprite {
    constructor({ position, velocity, color, offset, character }) {
        this.position = position;
        this.velocity = velocity;
        this.width = 50;
        this.height = 150;
        this.lastKey;
        this.attackBox = {
            position: {
                x: this.position.x,
                y: this.position.y
            },
            offset,
            width: 100,
            height: 50
        }
        this.color = color;
        this.isAttacking;
        this.health = 100;
        this.character = character; // NEW: Character to draw
    }

    draw() {
        // --- FIX: Draw player as text instead of a rectangle ---
        ctx.font = '80px Arial'; // Set a large font size
        ctx.fillStyle = this.color;
        ctx.textAlign = 'center'; // Center the text horizontally
        ctx.textBaseline = 'middle'; // Center the text vertically

        // Calculate the center of the player's position
        const centerX = this.position.x + this.width / 2;
        const centerY = this.position.y + this.height / 2;

        // Draw the character (e.g., "1" or "2")
        ctx.fillText(this.character, centerX, centerY);
    }

    update() {
        this.draw();
        this.attackBox.position.x = this.position.x + this.attackBox.offset.x;
        this.attackBox.position.y = this.position.y;

        this.position.y += this.velocity.y;
        this.position.x += this.velocity.x;

        // Gravity
        if (this.position.y + this.height + this.velocity.y < canvas.height) {
            this.velocity.y += GRAVITY;
        } else {
            this.velocity.y = 0;
        }
    }

    attack() {
        this.isAttacking = true;
        setTimeout(() => {
            this.isAttacking = false;
        }, 100);
    }
}

// --- PLAYER INSTANCES ---
const player1 = new Sprite({
    position: {
        x: 100,
        y: 0
    },
    velocity: {
        x: 0,
        y: 0
    },
    color: 'blue',
    offset: {
        x: 0,
        y: 0
    },
    character: '1' // NEW: Player 1 is the number "1"
});

const player2 = new Sprite({
    position: {
        x: 800,
        y: 0
    },
    velocity: {
        x: 0,
        y: 0
    },
    color: 'red',
    offset: {
        x: -50,
        y: 0
    },
    character: '2' // NEW: Player 2 is the number "2"
});

// --- INPUT HANDLING ---
const keys = {
    a: { pressed: false },
    d: { pressed: false },
    w: { pressed: false },
    ArrowLeft: { pressed: false },
    ArrowRight: { pressed: false },
    ArrowUp: { pressed: false }
};

window.addEventListener('keydown', (event) => {
    if (!gameOver) {
        switch (event.key) {
            case 'd': keys.d.pressed = true; player1.lastKey = 'd'; break;
            case 'a': keys.a.pressed = true; player1.lastKey = 'a'; break;
            case 'w': 
                if (player1.position.y + player1.height >= canvas.height - 10) {
                    player1.velocity.y = -15;
                }
                break;
            case ' ': player1.attack(); break;

            case 'ArrowRight': keys.ArrowRight.pressed = true; player2.lastKey = 'ArrowRight'; break;
            case 'ArrowLeft': keys.ArrowLeft.pressed = true; player2.lastKey = 'ArrowLeft'; break;
            case 'ArrowUp':
                if (player2.position.y + player2.height >= canvas.height - 10) {
                    player2.velocity.y = -15;
                }
                break;
            case 'ArrowDown': player2.attack(); break;
        }
    }
});

window.addEventListener('keyup', (event) => {
    switch (event.key) {
        case 'd': keys.d.pressed = false; break;
        case 'a': keys.a.pressed = false; break;
        case 'ArrowRight': keys.ArrowRight.pressed = false; break;
        case 'ArrowLeft': keys.ArrowLeft.pressed = false; break;
    }
});

// --- COLLISION DETECTION ---
function rectangularCollision({ rectangle1, rectangle2 }) {
    return (
        rectangle1.attackBox.position.x + rectangle1.attackBox.width >= rectangle2.position.x &&
        rectangle1.attackBox.position.x <= rectangle2.position.x + rectangle2.width &&
        rectangle1.attackBox.position.y + rectangle1.attackBox.height >= rectangle2.position.y &&
        rectangle1.attackBox.position.y <= rectangle2.position.y + rectangle2.height
    )
}

// --- GAME STATE & LOGIC ---
let timer = 60;
let gameOver = false;

function determineWinner({ player1, player2 }) {
    gameOver = true;
    gameOverDisplay.classList.remove('hidden');

    if (player1.health === player2.health) {
        winnerText.innerHTML = 'Tie!';
    } else if (player1.health > player2.health) {
        winnerText.innerHTML = 'Player 1 Wins!';
    } else {
        winnerText.innerHTML = 'Player 2 Wins!';
    }
}

// --- ANIMATION LOOP ---
function animate() {
    window.requestAnimationFrame(animate);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    player1.update();
    player2.update();

    // Player 1 Movement
    player1.velocity.x = 0;
    if (keys.d.pressed && player1.lastKey === 'd') {
        player1.velocity.x = 5;
    } else if (keys.a.pressed && player1.lastKey === 'a') {
        player1.velocity.x = -5;
    }

    // Player 2 Movement
    player2.velocity.x = 0;
    if (keys.ArrowRight.pressed && player2.lastKey === 'ArrowRight') {
        player2.velocity.x = 5;
    } else if (keys.ArrowLeft.pressed && player2.lastKey === 'ArrowLeft') {
        player2.velocity.x = -5;
    }

    // Detect for collision
    if (rectangularCollision({ rectangle1: player1, rectangle2: player2 }) && player1.isAttacking) {
        player1.isAttacking = false;
        player2.health -= 10;
        player2HealthBar.style.width = player2.health + '%';
    }

    if (rectangularCollision({ rectangle1: player2, rectangle2: player1 }) && player2.isAttacking) {
        player2.isAttacking = false;
        player1.health -= 10;
        player1HealthBar.style.width = player1.health + '%';
    }

    // End game based on health
    if (player1.health <= 0 || player2.health <= 0) {
        determineWinner({ player1, player2 });
    }
}

// --- RESTART FUNCTION ---
function resetGame() {
    player1.health = 100;
    player2.health = 100;
    player1.position = { x: 100, y: 0 };
    player2.position = { x: 800, y: 0 };
    player1.velocity = { x: 0, y: 0 };
    player2.velocity = { x: 0, y: 0 };
    
    player1HealthBar.style.width = '100%';
    player2HealthBar.style.width = '100%';

    gameOver = false;
    gameOverDisplay.classList.add('hidden');
    
    timer = 60;
    if (timerDisplay) {
        timerDisplay.innerHTML = timer;
    }
}

restartButton.addEventListener('click', resetGame);

// --- START THE GAME ---
animate();
